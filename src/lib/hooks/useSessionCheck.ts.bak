import { useEffect, useCallback, useRef } from "@/lib/vendors";
import { useNavigate } from "@/lib/vendors";
import { store } from "@/services/store";
import {
  handleLogout,
  getUserDetails,
  checkUserExists,
  login,
  handleLoginSuccess,
  updateUser,
} from "@/services/backend/actions";

// Types
interface User {
  id: string;
  email: string;
  password?: string;
}

interface AuthState {
  isLoggedIn: boolean;
  user: User | null;
  session: any;
  isSubscribed?: boolean;
  isSubscriptionExpired?: boolean;
  expiryDate?: string | null;
  forcePasswordReset?: boolean;
}

interface SessionCheckState {
  isRetrying: boolean;
  lastSuccessfulCheck: Date | null;
  retryCount: number;
  deviceId: string;
}

// Constants for intervals and timeouts
const CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes
const SESSION_EXPIRY_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
const NETWORK_RETRY_DELAY = 5000; // 5 seconds
const MAX_RETRIES = 3;

// Generate a unique device ID
const generateDeviceId = (): string => {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2);
  return `${timestamp}-${random}`;
};

// Check subscription status based on expiry date and soft delete status
const checkSubscriptionStatus = (
  expiryDate: string | null,
  isDeleted: boolean = false
): { isSubscribed: boolean; isSubscriptionExpired: boolean } => {
  // Per memory requirement - if user is soft deleted, they have no subscription
  if (isDeleted) {
    return { isSubscribed: false, isSubscriptionExpired: true };
  }

  if (!expiryDate) {
    return { isSubscribed: false, isSubscriptionExpired: false };
  }

  const currentDate = new Date();
  const expiry = new Date(expiryDate);
  const isExpired = currentDate > expiry;

  return {
    isSubscribed: !isExpired,
    isSubscriptionExpired: isExpired,
  };
};nst useSessionCheck = (): void => {
  const navigate = useNavigate();
  const { isLoggedIn, user } = store.auth.get() as AuthState;

  // Early return if not logged in or no user
  if (!isLoggedIn || !user) return;
  
  // Maintain session check state
  const sessionState = useRef<SessionCheckState>({
    isRetrying: false,
    lastSuccessfulCheck: null,
    retryCount: 0,
    deviceId: generateDeviceId(),
  });

  // Check session and force flags
  const checkStatus = useCallback(async (isFullCheck = false): Promise<void> => {
    try {
      if (navigator.onLine) {
        sessionState.current.retryCount = 0;
      }

      // Step 1: Check if user still exists and get stored password
      // Always enforce soft delete filter per memory requirement
      const existingUser = await checkUserExists(user.email, {
        fields: "id,email,password,force_password_reset,force_logout,last_login,device_id",
        filter: "is_deleted:0", // Enforce soft delete filter
      });

      if (!existingUser?.result?.length) {
        console.error("User not found in auth check");
        handleLogout();
        navigate("/login", { replace: true });
        return;
      }

      const userData = existingUser.result[0];

      // Handle concurrent sessions
      if (userData.device_id && userData.device_id !== sessionState.current.deviceId) {
        console.warn("Session active on another device");
        handleLogout();
        navigate("/login", { replace: true, state: { reason: "concurrent_session" } });
        return;
      }

      // Check session expiry if it's a full check
      if (isFullCheck && userData.last_login) {
        const lastLogin = new Date(userData.last_login).getTime();
        const currentTime = new Date().getTime();
        if (currentTime - lastLogin > SESSION_EXPIRY_INTERVAL) {
          console.warn("Session expired");
          handleLogout();
          navigate("/login", { replace: true, state: { reason: "session_expired" } });
          return;
        }
      }

      // Step 2: Handle force password reset
      if (userData.force_password_reset) {
        store.auth.set({ forcePasswordReset: true });
        await updateUser(userData.id, { force_password_reset: 0 });
        navigate("/password-reset", { replace: true });
        return;
      }

      // Step 3: Handle force logout
      if (userData.force_logout) {
        await updateUser(userData.id, { force_logout: 0 });
        handleLogout();
        navigate("/login", { replace: true });
        return;
      }

      // Step 4: Attempt auto-login with stored hash
      const loginResponse = await login({
        email: userData.email,
        password: userData.password, // Use stored hash for auto-login
      });

      if (loginResponse.err) {
        console.error("Failed to refresh session", loginResponse.err);
        handleLogout();
        navigate("/login", { replace: true });
        return;
      }

      // Step 5: Update store with fresh data and device ID
      const loginResult = handleLoginSuccess(loginResponse);
      if (!loginResult.success) {
        handleLogout();
        navigate("/login", { replace: true });
        return;
      }

      // Update device ID and last login
      await updateUser(userData.id, {
        device_id: sessionState.current.deviceId,
        last_login: new Date().toISOString(),
      });

      // Get full user details after successful login
      const response = await getUserDetails(userData.id, {
        fields:
          "id,name,email,image,expiry_date,is_admin,is_deleted,update_password,force_logout,force_password_reset,last_login,device_id",
        filter: "is_deleted:0", // Enforce soft delete filter
      });

      if (response.err || !response.result) {
        console.error("Failed to fetch user details", response.err);
        handleLogout();
        navigate("/login", { replace: true });
        return;
      }

      const fullUserData = response.result;

      // If user is soft deleted, force logout per memory requirement
      if (fullUserData.is_deleted) {
        handleLogout();
        navigate("/login", { replace: true });
        return;
      }

      // Check subscription status and update store
      const { isSubscribed, isSubscriptionExpired } = checkSubscriptionStatus(
        fullUserData.expiry_date,
        Boolean(fullUserData.is_deleted)
      );

      // Update session state on successful check
      sessionState.current.lastSuccessfulCheck = new Date();
      sessionState.current.isRetrying = false;
      sessionState.current.retryCount = 0;

      store.auth.set({
        isSubscribed,
        isSubscriptionExpired,
        expiryDate: fullUserData.expiry_date,
      });
    } catch (error: unknown) {
      const err = error as Error;
      console.error("Error checking session status:", err);
      
      // Handle network errors with retry logic
      if (!navigator.onLine || (err.message && err.message.includes("network"))) {
        sessionState.current.isRetrying = true;
        if (sessionState.current.retryCount < MAX_RETRIES) {
          sessionState.current.retryCount++;
          setTimeout(() => void checkStatus(false), NETWORK_RETRY_DELAY * sessionState.current.retryCount);
          return;
        }
      }

      handleLogout();
      navigate("/login", { replace: true });
    }
  }, [navigate, user]);

  // Handle network status changes
  const handleNetworkChange = useCallback(() => {
    if (navigator.onLine && sessionState.current.isRetrying) {
      void checkStatus(false); // Retry check when network is restored
    }
  }, [checkStatus]);
  
  // Handle tab visibility changes
  const handleVisibilityChange = useCallback(() => {
    if (document.visibilityState === 'visible') {
      void checkStatus(false);
    }
  }, [checkStatus]);

  // Set up network status and visibility listeners
  useEffect(() => {
    window.addEventListener("online", handleNetworkChange);
    window.addEventListener("offline", handleNetworkChange);
    document.addEventListener("visibilitychange", handleVisibilityChange);
    
    return () => {
      window.removeEventListener("online", handleNetworkChange);
      window.removeEventListener("offline", handleNetworkChange);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [handleNetworkChange, handleVisibilityChange]);
  
  // Initial check and periodic checks
  useEffect(() => {
    void checkStatus(true);

    const lightCheckInterval = setInterval(() => void checkStatus(false), CHECK_INTERVAL);
    const fullCheckInterval = setInterval(() => void checkStatus(true), SESSION_EXPIRY_INTERVAL);

    return () => {
      clearInterval(lightCheckInterval);
      clearInterval(fullCheckInterval);
    };
  }, [checkStatus]);
};
          sessionState.current.isRetrying = true;
          if (sessionState.current.retryCount < MAX_RETRIES) {
            sessionState.current.retryCount++;
            setTimeout(() => void checkStatus(false), NETWORK_RETRY_DELAY * sessionState.current.retryCount);
            return;
          }
        }

        handleLogout();
        navigate("/login", { replace: true });
      }
    }, [navigate, user]);

  // Handle network status
  const handleNetworkChange = useCallback(() => {
    if (navigator.onLine && sessionState.current.isRetrying) {
      void checkStatus(false); // Retry check when network is restored
    }
  }, [checkStatus]);

  // Set up network status listeners
  useEffect(() => {
    window.addEventListener("online", handleNetworkChange);
    window.addEventListener("offline", handleNetworkChange);
    return () => {
      window.removeEventListener("online", handleNetworkChange);
      window.removeEventListener("offline", handleNetworkChange);
    
  }, [handleNetworkChange]);

  // Initial check and periodic checks
  useEffect(() => {
    // Initial check
    void checkStatus(true);

    // Set up periodic checks
    const lightCheckInterval = setInterval(() => void checkStatus(false), CHECK_INTERVAL);
    const fullCheckInterval = setInterval(() => void checkStatus(true), SESSION_EXPIRY_INTERVAL);

    // Clean up intervals
    return () => {
      clearInterval(lightCheckInterval);
      clearInterval(fullCheckInterval);
    
  }, [checkStatus]);


        
        // Handle network errors with retry logic
        if (!navigator.onLine || (err.message && err.message.includes("network"))) {
          sessionState.current.isRetrying = true;
          if (sessionState.current.retryCount < MAX_RETRIES) {
            sessionState.current.retryCount++;
            setTimeout(() => void checkStatus(false), NETWORK_RETRY_DELAY * sessionState.current.retryCount);
            return;
          }
        }

        handleLogout();
        navigate("/login", { replace: true });
      }
    }, [navigate, user]);

  // Set up network status listeners
  useEffect(() => {
    window.addEventListener("online", handleNetworkChange);
    window.addEventListener("offline", handleNetworkChange);
    return () => {
      window.removeEventListener("online", handleNetworkChange);
      window.removeEventListener("offline", handleNetworkChange);
    
  }, [handleNetworkChange]);

  // Initial check and periodic checks
  useEffect(() => {
    if (!isLoggedIn || !user?.id) return;
    
    // Initial check
    void checkStatus(true);

    // Set up periodic checks
    const lightCheckInterval = setInterval(() => void checkStatus(false), CHECK_INTERVAL);
    const fullCheckInterval = setInterval(() => void checkStatus(true), SESSION_EXPIRY_INTERVAL);

    // Clean up intervals
    return () => {
      clearInterval(lightCheckInterval);
      clearInterval(fullCheckInterval);
    
  }, [checkStatus, isLoggedIn, user]);

        
        // Handle network errors with retry logic
        if (!navigator.onLine || (err.message && err.message.includes("network"))) {
          sessionState.current.isRetrying = true;
          if (sessionState.current.retryCount < MAX_RETRIES) {
            sessionState.current.retryCount++;
            setTimeout(() => void checkStatus(false), NETWORK_RETRY_DELAY * sessionState.current.retryCount);
            return;
          }
        }

        handleLogout();
        navigate("/login", { replace: true });
      }
    }, [navigate, user]);

  // Handle network status
  const handleNetworkChange = useCallback(() => {
    if (navigator.onLine && sessionState.current.isRetrying) {
      void checkStatus(false); // Retry check when network is restored
    }
  }, [checkStatus]);

  // Set up network status listeners
  useEffect(() => {
    window.addEventListener("online", handleNetworkChange);
    window.addEventListener("offline", handleNetworkChange);
    return () => {
      window.removeEventListener("online", handleNetworkChange);
      window.removeEventListener("offline", handleNetworkChange);
    
  }, [handleNetworkChange]);

  // Initial check and periodic checks
  useEffect(() => {
    if (!isLoggedIn || !user?.id) return;
    
    // Initial check
    void checkStatus(true);

    // Set up periodic checks
    const lightCheckInterval = setInterval(() => void checkStatus(false), CHECK_INTERVAL);
    const fullCheckInterval = setInterval(() => void checkStatus(true), SESSION_EXPIRY_INTERVAL);

    // Clean up intervals
    return () => {
      clearInterval(lightCheckInterval);
      clearInterval(fullCheckInterval);
    
  }, [checkStatus, isLoggedIn, user]);

        
        // Handle network errors with retry logic
        if (!navigator.onLine || (err.message && err.message.includes("network"))) {
          sessionState.current.isRetrying = true;
          if (sessionState.current.retryCount < MAX_RETRIES) {
            sessionState.current.retryCount++;
            setTimeout(() => checkStatus(), NETWORK_RETRY_DELAY * sessionState.current.retryCount);
            return;
          }
        }

        handleLogout();
        navigate("/login", { replace: true });
      }
    

    // Initial check
    checkStatus(true); // Full check on mount

    // Set up periodic checks
    const lightCheckInterval = setInterval(() => checkStatus(false), CHECK_INTERVAL);
    const fullCheckInterval = setInterval(() => checkStatus(true), SESSION_EXPIRY_INTERVAL);

    // Check status when tab regains focus or network status changes
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        checkStatus(true);
      }
    

    // Add network status listeners
    window.addEventListener("online", handleNetworkChange);
    window.addEventListener("offline", handleNetworkChange);
    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      clearInterval(lightCheckInterval);
      clearInterval(fullCheckInterval);
      window.removeEventListener("online", handleNetworkChange);
      window.removeEventListener("offline", handleNetworkChange);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    
  }, [isLoggedIn, user?.id, navigate]);

  // Handle network status
  const handleNetworkChange = useCallback(() => {
    if (navigator.onLine && sessionState.current.isRetrying) {
      void checkStatus(false); // Retry check when network is restored
    }
  }, []);

  // Set up network status listeners
  useEffect(() => {
    window.addEventListener("online", handleNetworkChange);
    window.addEventListener("offline", handleNetworkChange);
    return () => {
      window.removeEventListener("online", handleNetworkChange);
      window.removeEventListener("offline", handleNetworkChange);
    
  }, [handleNetworkChange]);

  // Initial check and periodic checks
  useEffect(() => {
    if (!isLoggedIn || !user?.id) return;

    // Initial check
    void checkStatus(true);

    // Set up periodic checks
    const lightCheckInterval = setInterval(() => void checkStatus(false), CHECK_INTERVAL);
    const fullCheckInterval = setInterval(() => void checkStatus(true), SESSION_EXPIRY_INTERVAL);

    // Clean up intervals
    return () => {
      clearInterval(lightCheckInterval);
      clearInterval(fullCheckInterval);
    
  }, [isLoggedIn, user?.id]);

